{"mappings":"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","sources":["src/js/coem/errors.js","src/js/coem/tokenizer.js","src/js/coem/types.js","src/js/coem/parser.js","src/js/coem/interpreter.js","src/js/coem/environment.js","src/js/coem/coem.js","src/js/scripts.js"],"sourcesContent":["const nullable = str => (str ? str : '')\n\nclass CoemError {\n  constructor(msg, startCoordinates, endCoordinates) {\n    this.msg = msg;\n    this.startCoordinates = startCoordinates;\n    this.endCoordinates = endCoordinates;\n  }\n\n  toString() {\n    return this.msg;\n  }\n}\n\nclass RuntimeError extends CoemError {\n  constructor(msg, token) {\n    super(\n      `${nullable(token.lexeme && `at \"${token.lexeme}\": `)}${msg}`,\n      token.startCoordinates,\n      token.endCoordinates\n    );\n  }\n}\n\nclass ReturnError {\n  constructor(val) {\n    this.value = val;\n  }\n}\n\nconst error = (msg, startCoordinates, endCoordinates) => {\n  new CoemError(msg, startCoordinates, endCoordinates);\n}\n\nconst parseError = (msg, token) => {\n  if (token.type === token.EOF) {\n    return new CoemError(msg, token.startCoordinates, token.endCoordinates);\n  } else {\n    return new CoemError(\n      `${nullable(token.lexeme && `at \"${token.lexeme}\": `)}${msg}`,\n      token.startCoordinates,\n      token.endCoordinates\n    );\n  }\n}\n\nconst runtimeError = (msg, token) => new RuntimeError(msg, token);\n\nconst formatCoemError = (e, code) => {\n  if (e instanceof CoemError) {\n    const frontIndex = code.lastIndexOf('\\n', e.startCoordinates.index);\n    const preErrorStart = frontIndex < 0 ? 0 : frontIndex;\n    const preErrorSection = code.substring(preErrorStart, e.startCoordinates.index);\n\n    // Error String\n    const errorSection = code.substring(e.startCoordinates.index, e.endCoordinates.index);\n\n    // Post Error String\n    const backIndex = code.indexOf('\\n', e.endCoordinates.index);\n    const postErrorStart = backIndex < 0 ? code.length : backIndex;\n    const postErrorSection = code.substring(e.endCoordinates.index, postErrorStart);\n\n    // Print Critical Code\n    const errorType = e instanceof RuntimeError ? 'Runtime Error' : 'Parse Error';\n    return {\n      oneLiner: `${errorType}: ${e.toString()} at ${e.endCoordinates.line}:${e.endCoordinates.col +\n        1}`,\n      preErrorSection,\n      errorSection,\n      postErrorSection\n    };\n  } else {\n    return {\n      oneLiner: `Unexpected JavaScript. Error: ${e}`\n    };\n  }\n}\n\nmodule.exports = {\n  error,\n  CoemError,\n  ReturnError,\n  runtimeError,\n  parseError,\n  formatCoemError\n};","const { CoemError } = require('./errors');\nconst noop = () => {};\n\nconst tokens = `\n  COLON,\n  COMMA, DOT,\n  EMDASH,\n  AMPERSAND,\n  POUND,\n\n  IDENTIFIER, STRING,\n\n  AND, OR,\n  IS, AM, ARE,\n  IF, ELSE, WHILE,\n  LET, BE,\n  TO, \n  TRUE, FALSE, NOTHING,\n  NOT,\n\n  NEWLINE,\n\n  EOF\n`\n  .split(',')\n  .map(token => token.trim());\n\nlet tokenEnum = {};\ntokens.forEach((token, i) => {\n  tokenEnum[token] = i;\n})\n\nconst keywords = {\n  and: tokenEnum.AND,\n  or: tokenEnum.OR,\n  is: tokenEnum.IS,\n  am: tokenEnum.AM,\n  are: tokenEnum.ARE,\n  not: tokenEnum.NOT,\n  true: tokenEnum.TRUE,\n  false: tokenEnum.FALSE,\n  nothing: tokenEnum.NOTHING,\n  let: tokenEnum.LET,\n  be: tokenEnum.BE,\n  to: tokenEnum.TO,\n  if: tokenEnum.IF,\n  else: tokenEnum.ELSE,\n  while: tokenEnum.WHILE,\n};\n\nconst tokenMap = {\n  '—': tokenizer => {\n    tokenizer.addToken(tokenEnum.EMDASH);\n  },\n  ':': tokenizer => {\n    tokenizer.addToken(tokenEnum.COLON);\n  },\n  ',': tokenizer => {\n    tokenizer.addToken(tokenEnum.COMMA);\n  },\n  '.': tokenizer => {\n    tokenizer.addToken(tokenEnum.DOT);\n  },\n  '&': tokenizer => {\n    tokenizer.addToken(tokenEnum.AMPERSAND);\n  },\n  '#': tokenizer => {\n    tokenizer.addToken(tokenEnum.POUND);\n  },\n  '†': tokenizer => {\n    // comments\n    while (tokenizer.peek() !== '\\n' && tokenizer.peek() !== '') tokenizer.advance();\n  },\n  ' ': noop,\n  '\\t': noop,\n  '\\r': noop,\n  '\\n': tokenizer => {\n    tokenizer.addToken(tokenEnum.NEWLINE);\n    tokenizer.newline();\n  },\n  '“': tokenizer => {\n    tokenizer.handleStringLiterals();\n  }\n}\n\n// const isAlpha = str => /[a-zA-Z_]/.test(str)\n// const isAlphaNumeric = str => isAlpha(str) || isDigit(str)\n\nconst isIdentifierChar = (c) => {\n  return (\n    (c >= 'A' && c <= 'Z') ||\n    (c >= 'a' && c <= 'z') ||\n    (c == '(' || c == ')') ||\n    (c == '[' || c == ']') ||\n    (c == '|' || c == '?' || c == '*' || c == '+')\n  );\n};\n\nclass Tokenizer {\n  static get tokens() {\n    return tokens;\n  }\n\n  static get tokenEnum() {\n    return tokenEnum;\n  }\n  constructor(source) {\n    this.source = source;\n    this.length = source.length;\n    this.tokens = [];\n    this.startPosition = null;\n    this.column = 0;\n    this.start = 0;\n    this.line = 1;\n    this.current = 0;\n  }\n\n  handleStringLiterals() {\n    while (this.peek() !== '”' && this.peek() !== '') {\n      if (this.peek() === '\\n') this.newline();\n      this.advance();\n    }\n\n    if (this.peek() === '') {\n      throw new CoemError('Unfinished string', this.startPosition, this.endPosition);\n    }\n\n    // The closing \".\n    this.advance();\n\n    // Trim the surrounding quotes.\n    const value = this.source.substring(this.start + 1, this.current - 1);\n    this.addToken(tokenEnum.STRING, value);\n  }\n\n  handleIdentifiers() {\n    while (isIdentifierChar(this.peek())) this.advance();\n    const value = this.source.substring(this.start, this.current);\n    if (keywords[value]) {\n      this.addToken(keywords[value], value);\n    } else {\n      this.addToken(tokenEnum.IDENTIFIER, value);\n    }\n  }\n\n  scanTokens() {\n    while (this.current < this.length) {\n      const c = this.advance()\n      this.startPosition = new Coordinate(this.column - 1, this.line, this.current - 1)\n      if (!tokenMap[c]) {\n        if (isIdentifierChar(c)) {\n          this.handleIdentifiers();\n        } else {\n          // Column isn't -1 because we haven't iterated column yet\n          throw new CoemError(\n            `Unexpected character ${c}`,\n            this.startPosition,\n            new Coordinate(this.column, this.line, this.current)\n          );\n        }\n      } else {\n        tokenMap[c](this);\n      }\n      this.start = this.current;\n    }\n    this.addToken(tokenEnum.EOF);\n    return this.tokens;\n  }\n\n  get endPosition() {\n    return new Coordinate(this.column - 1, this.line, this.current);\n  }\n\n  addToken(type, literal = null) {\n    const text = this.source.substring(this.start, this.current);\n    this.tokens.push(\n      new Token(\n        type,\n        text,\n        literal,\n        new Coordinate(this.column, this.line, this.current),\n        this.startPosition\n      )\n    );\n  }\n\n  increment() {\n    this.current++;\n    this.column++;\n  }\n\n  newline() {\n    this.line++;\n    this.column = 0;\n  }\n\n  advance() {\n    this.increment();\n    return this.source.charAt(this.current - 1);\n  }\n\n  peek() {\n    return this.source.charAt(this.current);\n  }\n\n  nextMatch(expected) {\n    if (this.peek() !== expected) return false;\n    this.increment();\n    return true;\n  }\n}\n\nclass Coordinate {\n  constructor(col, line, index) {\n    this.col = col;\n    this.line = line;\n    this.index = index;\n  }\n}\n\nclass Token {\n  constructor(type, lexeme, literal, endCoordinates, startCoordinates) {\n    this.type = type;\n    this.lexeme = lexeme;\n    this.literal = literal;\n    this.startCoordinates = startCoordinates;\n    this.endCoordinates = endCoordinates;\n  }\n}\n\nmodule.exports = Tokenizer;","class Binary {\n  constructor(left, operator, right) {\n    this.left = left\n    this.operator = operator\n    this.right = right\n  }\n}\n\nclass Logical extends Binary {}\n\nclass Unary {\n  constructor(operator, right) {\n    this.operator = operator\n    this.right = right\n  }\n}\n\nclass Literal {\n  constructor(value) {\n    this.value = value\n  }\n}\n\nclass Var {\n  constructor(name) {\n    this.name = name\n  }\n}\n\nclass ExpressionStatement {\n  constructor(expression) {\n    this.expression = expression;\n  }\n}\n\nclass VarStatement {\n  constructor(name, value) {\n    this.name = name\n    this.value = value\n  }\n}\n\nclass Block {\n  constructor(statements) {\n    this.statements = statements\n  }\n}\n\nclass Condition {\n  constructor(condition, thenBranch, elseBranch) {\n    this.condition = condition\n    this.thenBranch = thenBranch\n    this.elseBranch = elseBranch\n  }\n}\n\nclass While {\n  constructor(condition, body) {\n    this.condition = condition\n    this.body = body\n  }\n}\n\nclass Call {\n  constructor(callee, paren, args) {\n    this.callee = callee\n    this.paren = paren\n    this.arguments = args\n  }\n}\n\nclass Return {\n  constructor(keyword, value) {\n    this.keyword = keyword\n    this.value = value\n  }\n}\n\nclass CoemFunction {\n  constructor(name, params, bodyStatements) {\n    this.name = name\n    this.params = params\n    this.bodyStatements = bodyStatements\n  }\n}\n\nclass Directive {\n  constructor(name, value) {\n    this.name = name;\n    this.value = value;\n  }\n}\n\nmodule.exports = {\n  Var,\n  Binary,\n  Unary,\n  Block,\n  Call,\n  While,\n  Literal,\n  Return,\n  Logical,\n  CoemFunction,\n  Condition,\n  ExpressionStatement,\n  VarStatement,\n  Directive\n}","const tokenizer = require('./tokenizer');\nconst {\n  Binary,\n  Unary,\n  Var,\n  Call,\n  Literal,\n  While,\n  Return,\n  CoemFunction,\n  ExpressionStatement,\n  VarStatement,\n  Logical,\n  Block,\n  Condition\n} = require('./types');\nconst { parseError: ParseError } = require('./errors');\nconst token = tokenizer.tokenEnum;\n\nclass Parser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.current = 0;\n    this.isParamListStarted = false;\n  }\n\n  parse() {\n    let statements = []\n    while (!this.isAtEnd) {\n      while (this.check(token.NEWLINE)) {\n        this.consume(token.NEWLINE, \"Expect newline between statements.\");\n      }\n      statements.push(this.declaration());\n    }\n\n    return statements;\n  }\n\n  declaration() {\n    if (this.match(token.POUND)) return this.directive();\n    if (this.match(token.TO)) return this.function();\n    if (this.match(token.LET)) return this.varDeclaration();\n\n    return this.statement();\n  }\n\n  directive() {\n    if (this.match(token.IDENTIFIER, token.BE)) {\n      const name = this.previous();\n      const value = this.consume(token.IDENTIFIER, \"Expect value after directive name.\");\n      return new DirectiveStatement(name, value);\n    }\n  }\n\n  function() {\n    const name = this.consume(token.IDENTIFIER, `Expect function name.`);\n    this.consume(token.EMDASH, `Expect '—' after function name.`);\n    let params = [];\n    if (!this.check(token.EMDASH)) {\n      do {\n        if (params.length >= 255) {\n          throw ParseError(\"Can't have more than 255 arguments.\", this.peek());\n        }\n\n        params.push(this.consume(token.IDENTIFIER, 'Expect identifier name.'));\n      } while (this.match(token.COMMA));\n    }\n    this.consume(token.EMDASH, `Expect '—' after arguments.`);\n\n    this.consume(token.COLON, `Expect ':' before function body.`);\n    const body = this.block();\n    return new CoemFunction(name, params, body);\n  }\n\n  block() {\n    let statements = [];\n\n    while (this.check(token.NEWLINE)) {\n      this.consume(token.NEWLINE, \"Expect newline between statements.\");\n    }\n\n    while (!this.check(token.DOT) && !this.isAtEnd) {\n      while (this.check(token.NEWLINE)) {\n        this.consume(token.NEWLINE, \"Expect newline between statements.\");\n      }\n      if (!this.check(token.DOT) && !this.isAtEnd) {\n        statements.push(this.declaration());\n      }\n    }\n\n    this.consume(token.DOT, \"Expect '.' after block.\");\n    return statements;\n  }\n\n  varDeclaration() {\n    const name = this.consume(token.IDENTIFIER, 'Expected variable name');\n\n    let value = null;\n    if (this.match(token.BE)) {\n      value = this.expression();\n    }\n\n    return new VarStatement(name, value);\n  }\n\n  expression() {\n    return this.or();\n  }\n\n  or() {\n    return this.matchBinary('and', Logical, token.OR)\n  }\n\n  and() {\n    return this.matchBinary('equality', Logical, token.AND)\n  }\n\n  matchBinary(method, Class, ...operators) {\n    let expr = this[method]()\n    while (this.match(...operators)) {\n      const operator = this.previous()\n      const right = this[method]()\n      expr = new Class(expr, operator, right)\n    }\n    return expr\n  }\n\n  equality() {\n    // return this.matchBinary('comparison', Binary, token.BANG_EQUAL, token.EQUAL_EQUAL)\n    // const expr = this.comparison();\n    let expr = this.unary();\n\n    // while (this.match(token.BANG_EQUAL, token.EQUAL_EQUAL, token.IS, token.AM, token.ARE)) {\n    while (this.match(token.IS, token.AM, token.ARE)) {\n      const operator = this.previous();\n      const right = this.unary();\n      expr = new Binary(expr, operator, right);\n    }\n\n    return expr;\n  }\n\n  unary() {\n    if (this.match(token.NOT)) {\n      const operator = this.previous();\n      const right = this.unary();\n      return new Unary(operator, right);\n    }\n    return this.call();\n  }\n\n  call() {\n    let expr = this.primary();\n    if (!this.isParamListStarted) {\n      //eslint-disable-next-line\n      while (true) {\n        if (this.match(token.EMDASH)) {\n          expr = this.finishCall(expr);\n        } else {\n          break;\n        }\n      }\n    }\n\n    return expr;\n  }\n\n  primary() {\n    if (this.match(token.FALSE)) return new Literal(false);\n    if (this.match(token.TRUE)) return new Literal(true);\n    if (this.match(token.NOTHING)) return new Literal(null);\n\n    if (this.match(token.STRING)) {\n      return new Literal(this.previous().literal);\n    }\n\n    if (this.match(token.IDENTIFIER)) {\n      return new Var(this.previous());\n    }\n\n    throw ParseError('Expect expression.', this.peek());\n  }\n\n  finishCall(callee) {\n    let args = [];\n\n    if (!this.check(token.EMDASH)) {\n      do {\n        if (args.length >= 255) {\n          throw ParseError(\"Can't have more than 255 arguments.\", this.peek());\n        }\n        this.isParamListStarted = true;\n        args.push(this.expression());\n        this.isParamListStarted = false;\n      } while (this.match(token.COMMA));\n    }\n\n    const dash = this.consume(token.EMDASH, \"Expect '—' after arguments.\");\n\n    return new Call(callee, dash, args);\n  }\n\n  statement() {\n    if (this.match(token.IF)) return this.ifStatement();\n    if (this.match(token.AMPERSAND)) return this.returnStatement();\n    if (this.match(token.WHILE)) return this.whileStatement();\n    if (this.match(token.COLON)) return new Block(this.block());\n\n    return this.expressionStatement()\n  }\n\n  ifStatement() {\n    this.consume(token.EMDASH, `Expect '—' after 'if'.`);\n    this.isParamListStarted = true;\n    const cond = this.expression();\n    this.consume(token.EMDASH, `Expect '—' after if condition.`);\n    this.isParamListStarted = false;\n\n    const thenBranch = this.statement();\n    let elseBranch = null;\n    if (this.match(token.ELSE)) {\n      elseBranch = this.statement();\n    }\n\n    return new Condition(cond, thenBranch, elseBranch);\n  }\n\n  returnStatement() {\n    const ampersand = this.previous();\n    let value = null;\n    if (!this.check(token.NEWLINE)) {\n      value = this.expression();\n    }\n\n    return new Return(ampersand, value);\n  }\n\n  whileStatement() {\n    this.consume(token.EMDASH, `Expect '—' after 'while'.`);\n    this.isParamListStarted = true;\n    const cond = this.expression();\n    this.consume(token.EMDASH, `Expect '—' after condition.`);\n    this.isParamListStarted = false;\n    const body = this.statement();\n\n    return new While(cond, body);\n  }\n\n  expressionStatement() {\n    const expr = this.expression();\n\n    // if it's a bare expression, print the expression\n    // but don't print a print statement\n    let wrapped = expr;\n    if (expr instanceof Call) {\n      const callee = expr.callee;\n      if (!callee.name === \"print\") {\n        wrapped = printExpression(expr);\n      }\n    } else {\n      wrapped = printExpression(expr);\n    }\n\n    return new ExpressionStatement(wrapped);\n  }\n\n  printExpression(expr) {\n    const printToken = new Token(token.IDENTIFIER, \"print\", null, peek().endCoordinates, peek().startCoordinates);\n    const printExpr = new Var(printToken);\n    const dash = new Token(token.emdash, \"—\", NULL, peek().endCoordinates, peek().startCoordinates);\n    let args = [expr];\n    const call = new Call(printExpr, dash, args);\n    return call;\n  }\n\n  consume(type, err) {\n    if (this.check(type)) return this.advance();\n\n    throw ParseError(err, this.peek());\n  }\n\n  // Checks if current token is one of the following tokens and advances to next token\n  match(...tokens) {\n    for (let token of tokens) {\n      if (this.check(token)) {\n        this.advance();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Verifies current token is equal to type\n  check(type) {\n    return !this.isAtEnd && this.peek().type === type;\n  }\n\n  get isAtEnd() {\n    return this.peek().type === token.EOF;\n  }\n\n  // Gets current token\n  peek() {\n    return this.tokens[this.current];\n  }\n\n  // Gets previous token\n  previous() {\n    if (this.current <= 0) throw ParseError('Expected previous but found nothing.', this.peek());\n    return this.tokens[this.current - 1];\n  }\n\n  // Advances parser to the next token\n  advance() {\n    if (!this.isAtEnd) this.current++;\n    return this.previous();\n  }\n}\n\nmodule.exports = Parser;","const { runtimeError, ReturnError } = require('./errors');\nconst {\n  Binary,\n  Unary,\n  Call,\n  Literal,\n  Logical,\n  Var,\n  Return,\n  While,\n  Block,\n  CoemFunction,\n  ExpressionStatement,\n  VarStatement,\n  Condition\n} = require('./types');\nconst Environment = require('./environment');\nconst tokenizer = require('./tokenizer');\nconst token = tokenizer.tokenEnum;\n\nconst isTruthy = val => Boolean(val);\nconst isEqual = (a, b) => a === b;\n\nclass CoemCallable {\n  constructor(declaration, closure) {\n    this.declaration = declaration\n    this.closure = closure\n  }\n\n  call(interpreter, args) {\n    const env = new Environment(this.closure);\n    for (let param = 0; param < this.declaration.params.length; param++) {\n      env.set(this.declaration.params[param], args[param]);\n    }\n    try {\n      interpreter.interpretBlock(this.declaration.bodyStatements, env);\n    } catch (ret) {\n      if (ret instanceof ReturnError) {\n        return ret.value;\n      } else {\n        throw ret;\n      }\n    }\n    return null;\n  }\n\n  toString() {\n    return `<${this.declaration.name.lexeme}()>`\n  };\n}\n;\nclass Interpreter {\n  constructor(environment, printfunc = console.log) {\n    this.printfunction = printfunc;\n    this.environment = environment || new Environment();\n    this.environment.setBuiltin('clock', () => new Date().getTime());\n    const nativePrint = (args) => {\n      if (args[0] === null) {\n        this.printfunction(\"nothing\");\n      } else {\n        this.printfunction(...args);\n      }\n    }\n    this.environment.setBuiltin('print', nativePrint);\n    this.environment.setBuiltin('know', nativePrint);\n    this.environment.setBuiltin('say', nativePrint);\n  }\n\n  interpret(expr) {\n    return this.evaluate(expr);\n  }\n\n  evaluate(expr) {\n    if (expr instanceof Block) return this.visitBlock(expr);\n    else if (expr instanceof CoemFunction) return this.visitFunction(expr);\n    else if (expr instanceof Logical) return this.visitLogical(expr);\n    else if (expr instanceof Call) return this.visitCall(expr);\n    else if (expr instanceof While) return this.visitWhile(expr);\n    else if (expr instanceof Condition) return this.visitCondition(expr);\n    else if (expr instanceof VarStatement) return this.visitVarStatement(expr);\n    else if (expr instanceof Return) return this.visitReturnStatement(expr);\n    // Doesn't need its own, it can just evaluate like grouping\n    else if (expr instanceof ExpressionStatement) return this.visitExpressionStmt(expr);\n    else if (expr instanceof Var) return this.visitVar(expr);\n    else if (expr instanceof Literal) return this.visitLiteral(expr);\n    else if (expr instanceof Unary) return this.visitUnary(expr);\n    else if (expr instanceof Binary) return this.visitBinary(expr);\n  }\n\n  visitLiteral(expr) {\n    return expr.value;\n  }\n  visitExpressionStmt(expr) {\n    return this.evaluate(expr.expression);\n  }\n  visitPrintStatement(expr) {\n    const val = this.evaluate(expr.expression);\n    this.printfunction(val === null ? 'nil' : val.toString());\n    return val;\n  }\n\n  visitFunction(expr) {\n    const fn = new CoemCallable(expr, this.environment);\n    this.environment.set(expr.name, fn);\n  }\n\n  visitLogical(expr) {\n    const left = this.evaluate(expr.left);\n    if (expr.operator.type === token.OR) {\n      if (isTruthy(left)) return left;\n    } else {\n      if (!isTruthy(left)) return left;\n    }\n\n    return this.evaluate(expr.right);\n  }\n\n  visitWhile(expr) {\n    while (isTruthy(this.evaluate(expr.condition))) {\n      this.evaluate(expr.body);\n    }\n    return null;\n  }\n\n  visitReturnStatement(stmt) {\n    var val = null;\n    if (stmt.value) val = this.evaluate(stmt.value);\n\n    throw new ReturnError(val);\n  }\n\n  visitVar(variable) {\n    return this.environment.get(variable);\n  }\n\n  visitVarStatement(variable) {\n    let value = null;\n    if (variable.value !== null) {\n      value = this.evaluate(variable.value);\n    }\n    this.environment.set(variable.name, value);\n    return null;\n  }\n\n  visitBlock(expr) {\n    this.interpretBlock(expr.statements, new Environment(this.environment));\n    return null;\n  }\n\n  visitCondition(expr) {\n    if (isTruthy(this.evaluate(expr.condition))) {\n      this.evaluate(expr.thenBranch);\n    } else if (expr.elseBranch) {\n      this.evaluate(expr.elseBranch);\n    }\n    return null;\n  }\n\n  interpretBlock(statements, env) {\n    const prevEnvironment = this.environment;\n    try {\n      this.environment = env;\n      for (let stmt of statements) {\n        this.interpret(stmt);\n      }\n      this.environment = prevEnvironment;\n    } catch (e) {\n      this.environment = prevEnvironment;\n      throw e;\n    }\n  }\n\n  visitCall(expr) {\n    const callee = this.evaluate(expr.callee);\n\n    let args = expr.arguments.map(arg => this.evaluate(arg));\n\n    if (!callee.call) {\n      throw runtimeError('Can only call functions.', expr.paren);\n    }\n\n    return callee.call(this, args)\n  }\n\n  visitUnary(expr) {\n    const right = this.evaluate(expr.right);\n    switch (expr.operator.type) {\n      case NOT:\n        return !isTruthy(right);\n    }\n  }\n\n  visitBinary(expr) {\n    const left = this.evaluate(expr.left);\n    const right = this.evaluate(expr.right);\n    switch (expr.operator.type) {\n      // Equality\n      case token.IS:\n      case token.AM:\n      case token.ARE:\n        return isEqual(left, right);\n      // case token.BANG_EQUAL:\n      //   return !isEqual(left, right);\n    }\n  }\n}\n\nmodule.exports = Interpreter;","const { runtimeError } = require('./errors');\n\nclass Environment {\n  constructor(enclosing = null) {\n    this.values = new Map();\n    this.enclosing = enclosing;\n  }\n\n  get(token) {\n    const set = this.getSet(token.name.lexeme);\n    if (set) {\n      return set[1];\n    }\n\n    // if not found in this environment, try enclosing one\n    if (this.enclosing) return this.enclosing.get(token);\n\n    // if not found after recursively walking up the chain, throw error\n    throw runtimeError(`Undefined variable '${token.name.lexeme}'.`, token.name);\n  }\n\n  getSet(name) {\n    // check each regex against name\n    for (const [key, value] of this.values.entries()) {\n      if (key.test(name)) {\n        return [key, value];\n      }\n    }\n    return null;\n  }\n\n  set(token, value) {\n    return this.setNameValue(token.lexeme, value);\n  }\n\n  setNameValue(name, value) {\n    let pattern = new RegExp(name);\n    let set = this.getSet(name);\n\n    // redefine in current environment\n    if (set) {\n      return this.values.set(set[0], value);\n    }\n\n    if (this.enclosing) {\n      let enclosingSet = this.enclosing.getSet(name);\n      // redefine in enclosing environment\n      if (enclosingSet) {\n        return this.enclosing.setNameValue(name, value);\n      }\n    }\n    \n    // define new in current environment\n    return this.values.set(pattern, value);\n  }\n\n  setBuiltin(name, func) {\n    // this.values.set(name, typeof func === 'function' ? { call: func } : func);\n    this.setNameValue(name, func);\n  }\n}\n\nmodule.exports = Environment;","// adapted from YALI.js by Daniel Berezin (danman113)\n// https://github.com/danman113/YALI.js\n\nconst Tokenizer = require('./tokenizer');\nconst Parser = require('./parser');\nconst Interpreter = require('./interpreter');\nconst Environment = require('./environment');\n\nfunction run(code, environment, printfn, debug = false) {\n  const tokenizer = new Tokenizer(code);\n  const tokens = tokenizer.scanTokens();\n  if (debug) console.log(tokens);\n  const parser = new Parser(tokens);\n  const statements = parser.parse();\n  if (debug) console.log(statements);\n  const interpreter = new Interpreter(environment, printfn);\n  let lastStatement;\n  for (let statement of statements) {\n    lastStatement = interpreter.interpret(statement);\n  }\n  return lastStatement;\n}\n\nfunction parse(code) {\n  const tokenizer = new Tokenizer(code);\n  const tokens = tokenizer.scanTokens();\n  const parser = new Parser(tokens);\n  const statements = parser.parse();\n  return statements;\n}\n\nmodule.exports = {\n  run,\n  parse,\n  Parser,\n  Tokenizer,\n  Interpreter,\n  Environment\n};","import { run, parse, Environment } from './coem/coem.js';\nimport { formatCoemError } from './coem/errors.js';\nimport { view } from './codemirror/setup.js';\n\nconst menuBtns = document.querySelectorAll(\".nav__item > button\"),\n  outputArea = document.querySelector(\".output\"),\n  consoleArea = document.querySelector(\".console\"),\n  filenameTitle = document.querySelector(\"h2 .filename-title\"),\n  tocItems = document.querySelector(\".toc__items\"),\n  tocBtns = document.querySelectorAll(\".toc__item button\"),\n  newBtn = document.querySelector(\"#newBtn\"),\n  draftBtn = document.querySelector(\"#draftBtn\");\nlet editor,\n  isMenuOpen = false,\n  currentTitle = \"Untitled\",\n  output = \"\";\n\n// MENU\n\nfunction onMenuBtnClick(e) {\n  e.preventDefault();\n  let btn = e.currentTarget;\n  isMenuOpen = btn.parentElement.classList.toggle(\"nav__item--open\");\n}\n\nfunction onMenuBtnMouseover(e) {\n  e.preventDefault();\n  let btn = e.currentTarget;\n  if (isMenuOpen) {\n    for (let b of menuBtns) {\n      b.parentElement.classList.remove(\"nav__item--open\");\n    }\n    btn.parentElement.classList.add(\"nav__item--open\");\n    btn.focus();\n  }\n}\n\nfunction onMenuBtnBlur(e) {\n  // e.preventDefault();\n  // let btn = e.currentTarget;\n  // btn.parentElement.classList.remove(\"nav__item--open\");\n}\n\nfunction onNewBtnClick(e) {\n  e.preventDefault();\n  let btn = e.currentTarget;\n  btn.parentElement.parentElement.parentElement.classList.remove(\"nav__item--open\");\n  isMenuOpen = false;\n  createNewFile();\n}\n\nfunction clear() {\n  view.dispatch({\n    changes: {from: 0, to: view.state.doc.length, insert: \"\"}\n  });\n  outputArea.innerHTML = \"\";\n  for (let btn of tocBtns) {\n    btn.parentElement.classList.remove(\"current\");\n  }\n}\n\nfunction createNewFile() {\n  clear();\n  let tocItem = document.querySelector(\".toc__item\").cloneNode(true);\n  filenameTitle.innerHTML = \"Untitled\";\n  currentTitle = filenameTitle;\n  tocItem.querySelector(\".filename-title\").innerHTML = \"Untitled\";\n  tocItems.appendChild(tocItem);\n}\n\n// TOC\n\nfunction onTocBtnClick(e) {\n  e.preventDefault();\n  let filename = e.target.value;\n  load(filename);\n}\n\n// LOAD\n\nfunction load(filename) {\n  Promise.all([\n    fetch(\"/examples/\" + filename + \".coem\"),\n    fetch(\"/examples/\" + filename + \".output\")\n  ])\n  .then(results => Promise.all(results.map(r => r.text())))\n  .then(([coem, output]) => {\n    editor.getDoc().setValue(coem);\n    outputArea.innerHTML = output;\n    filenameTitle.innerHTML = filename;\n    currentTitle = filenameTitle;\n    for (let btn of tocBtns) {\n      btn.parentElement.classList.remove(\"current\");\n    }\n    document.querySelector(\"button[value=\\\"\" + filename + \"\\\"]\").parentElement.classList.add(\"current\");\n  })\n  .catch(err => console.log(err));\n}\n\n// DRAFT\n\nfunction handleError(e, source = \"\") {\n  if (!e) {\n    consoleArea.innerHTML = \"\";\n    return null;\n  }\n  console.error(e);\n  const { oneLiner, preErrorSection, errorSection, postErrorSection } = formatCoemError(e, source);\n  let errorStr = oneLiner;\n  if (errorSection) {\n    errorStr += '<br />';\n    errorStr += `${preErrorSection}<span class=\"error\">${errorSection}</span>${postErrorSection}`;\n  }\n  consoleArea.innerHTML = errorStr;\n}\n\nfunction handleOutput(txt) {\n  output += txt + '\\n';\n  console.log(txt);\n  outputArea.innerHTML = output;\n}\n\nfunction draft() {\n  // https://github.com/danman113/YALI.js/blob/master/browser.js\n  const source = view.state.doc.toString();\n  console.log(source);\n  const browserEnv = new Environment();\n  output = \"\";\n  try {\n    run(source, browserEnv, handleOutput);\n    handleError(null);\n  } catch (e) {\n    handleError(e, source);\n  }\n}\n\n// MAIN\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  // load(\"Looking\");\n\n  // menuBtns.forEach(button => {\n  //   button.addEventListener(\"click\", onMenuBtnClick);\n  //   button.addEventListener(\"mouseover\", onMenuBtnMouseover);\n  //   button.addEventListener(\"blur\", onMenuBtnBlur);\n  // });\n\n  // newBtn.addEventListener(\"click\", onNewBtnClick);\n  \n  // tocBtns.forEach(btn => {\n  //   btn.addEventListener(\"click\", onTocBtnClick);\n  // });\n\n  draftBtn.addEventListener(\"click\", draft);\n});"],"names":["$461fe508b0c731f0$var$nullable","str","$461fe508b0c731f0$var$CoemError","msg","startCoordinates","endCoordinates","this","toString","$461fe508b0c731f0$var$RuntimeError","token","super","lexeme","$461fe508b0c731f0$exports","val","value","type","EOF","e","code","frontIndex","lastIndexOf","index","preErrorStart","preErrorSection","substring","errorSection","backIndex","indexOf","postErrorStart","length","postErrorSection","oneLiner","line","col","CoemError","$977b7524e40192e8$var$noop","$977b7524e40192e8$var$tokens","split","map","trim","$977b7524e40192e8$var$tokenEnum","forEach","i","$977b7524e40192e8$var$keywords","and","AND","or","OR","is","IS","am","AM","are","ARE","not","NOT","true","TRUE","false","FALSE","nothing","NOTHING","let","LET","be","BE","to","TO","if","IF","else","ELSE","while","WHILE","$977b7524e40192e8$var$tokenMap","tokenizer","addToken","EMDASH","COLON","COMMA","DOT","AMPERSAND","POUND","peek","advance","NEWLINE","newline","handleStringLiterals","$977b7524e40192e8$var$isIdentifierChar","c","$977b7524e40192e8$var$Coordinate","$977b7524e40192e8$var$Token","literal","$977b7524e40192e8$exports","tokens","tokenEnum","source","startPosition","column","start","current","$977b7524e40192e8$require$CoemError","endPosition","STRING","handleIdentifiers","IDENTIFIER","scanTokens","text","push","increment","charAt","nextMatch","expected","$3b3c2e89fca5b3a6$var$Binary","left","operator","right","$3b3c2e89fca5b3a6$exports","name","statements","callee","paren","args","arguments","condition","body","keyword","params","bodyStatements","thenBranch","elseBranch","expression","Binary","Unary","Var","Call","Literal","While","Return","CoemFunction","ExpressionStatement","VarStatement","Logical","Block","Condition","parseError","$66a0f91c58b0b50d$var$token","$66a0f91c58b0b50d$exports","isParamListStarted","parse","isAtEnd","check","consume","declaration","match","directive","function","varDeclaration","statement","previous","DirectiveStatement","$66a0f91c58b0b50d$require$ParseError","block","$66a0f91c58b0b50d$require$CoemFunction","$66a0f91c58b0b50d$require$VarStatement","matchBinary","$66a0f91c58b0b50d$require$Logical","method","Class","operators","expr","equality","unary","$66a0f91c58b0b50d$require$Binary","$66a0f91c58b0b50d$require$Unary","call","primary","finishCall","$66a0f91c58b0b50d$require$Literal","$66a0f91c58b0b50d$require$Var","dash","$66a0f91c58b0b50d$require$Call","ifStatement","returnStatement","whileStatement","$66a0f91c58b0b50d$require$Block","expressionStatement","cond","$66a0f91c58b0b50d$require$Condition","ampersand","$66a0f91c58b0b50d$require$Return","$66a0f91c58b0b50d$require$While","wrapped","printExpression","$66a0f91c58b0b50d$require$ExpressionStatement","printToken","Token","printExpr","emdash","NULL","err","runtimeError","ReturnError","$f53eb9824be699fa$exports","enclosing","values","Map","get","set","getSet","$f53eb9824be699fa$require$runtimeError","key","entries","test","setNameValue","pattern","RegExp","setBuiltin","func","$151eb2f6fc597851$var$token","$151eb2f6fc597851$var$isTruthy","Boolean","$151eb2f6fc597851$var$CoemCallable","closure","interpreter","env","param","interpretBlock","ret","$151eb2f6fc597851$require$ReturnError","$413687116a308d25$exports","environment","printfn","debug","console","log","$151eb2f6fc597851$exports","lastStatement","interpret","printfunc","printfunction","Date","getTime","nativePrint","evaluate","$151eb2f6fc597851$require$Block","visitBlock","$151eb2f6fc597851$require$CoemFunction","visitFunction","$151eb2f6fc597851$require$Logical","visitLogical","$151eb2f6fc597851$require$Call","visitCall","$151eb2f6fc597851$require$While","visitWhile","$151eb2f6fc597851$require$Condition","visitCondition","$151eb2f6fc597851$require$VarStatement","visitVarStatement","$151eb2f6fc597851$require$Return","visitReturnStatement","$151eb2f6fc597851$require$ExpressionStatement","visitExpressionStmt","$151eb2f6fc597851$require$Var","visitVar","$151eb2f6fc597851$require$Literal","visitLiteral","$151eb2f6fc597851$require$Unary","visitUnary","$151eb2f6fc597851$require$Binary","visitBinary","visitPrintStatement","fn","stmt","variable","prevEnvironment","arg","$151eb2f6fc597851$require$runtimeError","document","querySelectorAll","$d1fb52b33a57c03a$var$outputArea","querySelector","$d1fb52b33a57c03a$var$consoleArea","$d1fb52b33a57c03a$var$draftBtn","$d1fb52b33a57c03a$var$output","$d1fb52b33a57c03a$var$handleError","innerHTML","error","formatCoemError","errorStr","$d1fb52b33a57c03a$var$handleOutput","txt","$d1fb52b33a57c03a$var$draft","$jFN27","view","state","doc","browserEnv","Environment","run","addEventListener"],"version":3,"file":"index.5c2b2014.js.map"}