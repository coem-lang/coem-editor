import { ExternalTokenizer, ContextTracker, LRParser } from '@lezer/lr';
import { NodeProp } from '@lezer/common';
import { LRLanguage, indentNodeProp, delimitedIndent, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@codemirror/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const indent = 47,
  dedent = 48,
  newline$1 = 49,
  newlineBracketed = 50,
  newlineEmpty = 51,
  eof = 52,
  ArgList = 8,
  ParamList = 40;

const newline = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35;

const bracketed = [
  ArgList, ParamList
];

const newlines = new ExternalTokenizer((input, stack) => {
  if (input.next < 0) {
    input.acceptToken(eof);
  } else if (input.next != newline && input.next != carriageReturn) ; else if (stack.context.depth < 0) {
    input.acceptToken(newlineBracketed, 1);
  } else {
    input.advance();
    let spaces = 0;
    while (input.next == space || input.next == tab) { input.advance(); spaces++; }
    let empty = input.next == newline || input.next == carriageReturn || input.next == hash;
    input.acceptToken(empty ? newlineEmpty : newline$1, -spaces);
  }
}, {contextual: true, fallback: true});

const indentation = new ExternalTokenizer((input, stack) => {
  let cDepth = stack.context.depth;
  if (cDepth < 0) return
  let prev = input.peek(-1);
  if ((prev == newline || prev == carriageReturn) && stack.context.depth >= 0) {
    let depth = 0, chars = 0;
    for (;;) {
      if (input.next == space) depth++;
      else if (input.next == tab) depth += 8 - (depth % 8);
      else break
      input.advance();
      chars++;
    }
    if (depth != cDepth &&
        input.next != newline && input.next != carriageReturn && input.next != hash) {
      if (depth < cDepth) input.acceptToken(dedent, -chars);
      else input.acceptToken(indent);
    }
  }
});

function IndentLevel(parent, depth) {
  this.parent = parent;
  // -1 means this is not an actual indent level but a set of brackets
  this.depth = depth;
  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4);
}

const topIndent = new IndentLevel(null, 0);

const trackIndent = new ContextTracker({
  start: topIndent,
  reduce(context, term) {
    return context.depth < 0 && bracketed.indexOf(term) > -1 ? context.parent : context
  },
  shift(context, term, stack, input) {
    if (term == indent) return new IndentLevel(context, stack.pos - input.pos)
    if (term == dedent) return context.parent
    // if (term == ParenL || term == BracketL || term == BraceL) return new IndentLevel(context, -1)
    return context
  },
  hash(context) { return context.hash }
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,nothing:12, true:14, false:14, or:22, and:24, is:26, am:28, are:30, not:32, if:38, else:40, let:46, be:48, print:58, know:60, while:74, to:78};
const parser = LRParser.deserialize({
  version: 13,
  states: "-bO`QUOOOOQS'#C`'#C`OOQS'#Dh'#DhO!WQUO'#CuO!cQUO'#CvOOQS'#Dg'#DgO!qQUO'#DfOOQS'#Dm'#DmOOQS'#De'#DeOOQS'#DV'#DVQ`QUOOO!cQUO'#CrO!yQUO'#CxO#[QUO'#C{O#aQUO'#DQO!RQUO'#DSO#fQUO'#CdOOQS,58y,58yOOQS,59b,59bOOQS,5:Q,5:QOOQS-E7T-E7TO#mQUO,59^OOQS'#Dl'#DlO$ZQUO'#DkOOQS'#Dk'#DkO!yQUO'#CmOOQS,59d,59dO!yQUO,59gO!yQUO,59lO$tQUO,59nOOQS,59O,59OO$yQUO,59OO%OQUO'#DjO!cQUO1G.xO!yQUO,59QO!yQUO,59QO%WQUO,59QO!yQUO,59YO%iQUO,59XO&VQUO'#DnOOQS'#Dn'#DnO&bQUO1G/RO&gQUO1G/WO&lQUO'#DUO&tQUO1G/YOOQS1G.j1G.jO&yQUO,5:UO!yQUO'#DWOOQS7+$d7+$dO'yQUO1G.lO(QQUO1G.lOOQS1G.l1G.lO!yQUO1G.lO(XQUO1G.tO!yQUO,59hO&tQUO7+$mO&tQUO7+$rOOQS,59p,59pO(`QUO,59pO(eQUO'#DoO(mQUO'#C}OOQS7+$t7+$tOOQS-E7U-E7UOOQS,59r,59rOOQS7+$W7+$WO!yQUO7+$`OOQS1G/S1G/SO(rQUO<<HXO)sQUO<<H^OOQS1G/[1G/[O*tQUO,5:ZO!RQUO'#DZO*|QVO,59iOOQS<<Gz<<GzO+RQUOAN=sO,SQUOAN=sO&tQUOAN=xOOQS-E7X-E7XOOQS,59u,59uO,[QUO1G/TOOQS-E7W-E7WO,SQUOG23_O-PQUO,59tOOQSG23_G23_OOQSG23dG23dOOQS'#DX'#DXO-WQUO7+$oP-_QUO'#DYOOQSLD(yLD(yOOQS1G/`1G/`O&tQUO1G/`OOQS-E7V-E7VO-dQVO<<HZOOQS7+$z7+$zOOQSAN=uAN=u",
  stateData: "-l~O!WOS!TOS!SOSPOS~OTQOUQOVQOc]OgZOkSOm[On[Ou^Ow_O!RXO!]PO~OX`O!RiX!UiX~OTQOUQOVQO!]PO~O!RcO!UcO~OTQOUQOVQO`iO!]PO~OXkO~OXlO~OXnO~P!yOhqO!Rfa!Ufa~OZrO[sO]tO^tO_tO~OcuO!R!_X!U!_XX!_Xe!_Xh!_Xr!_X~P#xOX{O~OX}O~Oe!POX!^X~OTQOUQOVQO`!UO!]PO~Ocaa!Raa!UaaXaaeaahaadaaraa~P#xOh!WOX!bXr!bX~OX!XO~OX!YO~OX!ZO!]PO~Or!^O~Oe!POX!^a~O]tO^tO_tOZYicYi!RYi!UYiXYieYihYidYirYi~O[sO~P'RO[Yi~P'ROd!cO~P#xOX!gO~Oe!iOX!cX~O!R!jO~Od!mOToyUoyVoycoygoykoymoynoyuoywoy!Ooy!Roy!]oysoy~Od!nOTtyUtyVtyctygtyktymtyntyutywty!Oty!Rty!]tysty~Oe!iOX!ca~O!P!qO~Od!sOTo!RUo!RVo!Rco!Rgo!Rko!Rmo!Rno!Ruo!Rwo!R!Oo!R!Ro!R!]o!Rso!R~Oc!tOr!^O~OTQOUQOVQOc]OgZOkSOm[On[Ou^Ow_O!]PO~Or!^O~P!yOs#OO~P,[Oc!tO~O!Q#QO!U#QO~O",
  goto: "'x!dPPP!e!kPPP#]P#`PPPPPP#`#pPPP!ePP!e!eP!ePP#z$Q$VPP#zP#zP$o$r$x%O%U%[PPPPPPPPP%b%j%p%vP&g&j'O%j'l'uXTOY!q!xzQOSYZ[`iklqrstu!P!U!W!c!q!t!xQm_Q!]{R!p!iRaRmf[`iklrstu!P!U!W!c!tah[`kl!P!W!c!tXVOY!q!xVxkl!tQ!_|Q!e!XQ!f!YQ!u!mQ!v!nQ!z!sQ!{!tR#P!|R|mQYORdYQ!OpR!`!OQ!x!qR!}!xQ!l!eR!r!lQ!h!]R!o!hSXOYT!w!q!xXWOY!q!xXUOY!q!xWROY!q!xQbSQeZlf[`iklrstu!P!U!W!c!tR!QqRo`Qj[Qp`Uwkl!tQ!a!PQ!d!WR!k!c`g[`kl!P!W!c!tQviQ!RrQ!SsQ!TtQ!VuR!b!UQykQzlR!|!tR![{",
  nodeNames: "⚠ Comment Script CallExpression VariableName String Nothing Boolean ArgList — BinaryExpression or and is am are not UnaryExpression ConditionalExpression if else , AssignStatement let be ExpressionStatement ReturnStatement & PrintStatement print know IfStatement NamedExpression Body : . WhileStatement while FunctionDefinition to ParamList",
  maxTerm: 65,
  context: trackIndent,
  nodeProps: [
    [NodeProp.group, -4,4,5,6,7,"Expression"]
  ],
  skippedNodes: [0,1],
  repeatNodeCount: 5,
  tokenData: "%Z~ReXY!d[]!dpq!dvw#Oxy#Tyz#Tz{#T{|#T|}#x!O!P#}![!]$S!a!b#T!c!}#T!}#O#T#O#P!u#P#Q#T#T#o#T#p#q#T$Ih$Ii$X$Ip$Iq$^$It$Iu${~!iS!W~XY!d[]!dpq!d#O#P!u~!xQYZ!d]^!d~#TOk~~#YY!]~xy#Tyz#Tz{#T{|#T!a!b#T!c!}#T!}#O#T#P#Q#T#T#o#T#p#q#T~#}Oe~~$SOs~~$XOr~~$^OX~~$aTO$Iq$^$Iq$Ir$p$Ir$It$^$It$Iu$u$Iu~$^~$uOT~~$xPO~$^~%QRP~OY${Z]${^~${",
  tokenizers: [indentation, 0, newlines],
  topRules: {"Script":[0,2]},
  specialized: [{term: 59, get: value => spec_identifier[value] || -1}],
  tokenPrec: 0
});

// https://github.com/codemirror/lang-python/blob/main/src/python.ts
function indentBody(context, node) {
    let base = context.lineIndent(node.from);
    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
    // Don't consider blank, deindented lines at the end of the
    // block part of the block
    if (!/\S/.test(line.text) &&
        context.node.to < to + 100 &&
        !/\S/.test(context.state.sliceDoc(to, context.node.to)) &&
        context.lineIndent(context.pos, -1) <= base)
        return null;
    // A normally deindenting keyword that appears at a higher
    // indentation than the block should probably be handled by the next
    // level
    if (/^\s*(else:|else if:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
        return null;
    return base + context.unit;
}
/// A language provider based on the Coem parser,
/// extended with highlighting and indentation information.
const coemLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Body: context => { var _a; return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue(); },
                IfStatement: cx => /^\s*(else:|else if:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
                "ParamList ArgList": delimitedIndent({ closing: "—" }),
                Script: context => {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length >= context.node.to) {
                        let endBody = null;
                        for (let cur = context.node, to = cur.to;;) {
                            cur = cur.lastChild;
                            if (!cur || cur.to != to)
                                break;
                            if (cur.type.name == "Body")
                                endBody = cur;
                        }
                        if (endBody) {
                            let bodyIndent = indentBody(context, endBody);
                            if (bodyIndent != null)
                                return bodyIndent;
                        }
                    }
                    return context.continue();
                }
            }),
            styleTags({
                "while if else": tags.controlKeyword,
                "not and or is am are": tags.operatorKeyword,
                "let to": tags.definitionKeyword,
                "be": tags.operatorKeyword,
                "print": tags.keyword,
                Boolean: tags.bool,
                VariableName: tags.variableName,
                "CallExpression/VariableName": tags.function(tags.definition(tags.variableName)),
                "FunctionDefinition/VariableName": tags.function(tags.definition(tags.variableName)),
                Comment: tags.lineComment,
                String: tags.string,
                "—": tags.bracket,
                ",": tags.separator
            })
        ],
        strict: false
    }),
    languageData: {
        // closeBrackets: {
        //   brackets: ["(", "[", '"', "“", "—"]
        // },
        commentTokens: { line: "†" },
        indentOnInput: /^\s*([\}\]\)]|else:|else if:)$/
    }
});
/// Coem language support.
function coem() {
    return new LanguageSupport(coemLanguage);
}

export { coem, coemLanguage };
